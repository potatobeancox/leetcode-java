package com.potato.study.leetcodecn.p01692.t001;

import org.junit.Assert;

/**
 * 1692. 计算分配糖果的不同方式
 *
 * 现有 n 颗 不同 糖果（分别标记为 1 到 n ）和 k 个相同的手袋。请把糖果分配到各个手袋中并保证每个手袋里至少有一颗糖果。
 *
 * 不考虑手袋和糖果的摆放顺序，会有多种不同的分配方式。如果某种分配方式中其中一个手袋里的糖果与另一种分配方式中所有手袋里的糖果都不相同，则认为这两种分配方式不同。
 *
 * 例如，(1), (2,3) 与(2), (1,3)的分配方式是不同的，因为第一种分配方式中手袋(2,3)里的糖果2和3，在第二种分配方式中被分配到了手袋(2)和(1,3) 中。
 *
 * 已知整数 n 和 k, 请返回分配糖果的不同方式。返回的答案如果数值太大，请取109 + 7的模，并返回。
 *
 *  
 *
 * 示例 1：
 *
 *
 *
 * 输入：n = 3, k = 2
 * 输出：3
 * 解释：把糖果 3 分配到 2 个手袋中的一个，共有 3 种方式:
 * (1), (2,3)
 * (1,2), (3)
 * (1,3), (2)
 * 示例 2：
 *
 * 输入：n = 4, k = 2
 * 输出：7
 * 解释：把糖果 4 分配到 2 个手袋中的一个，共有 7 种方式:
 * (1), (2,3,4)
 * (1,2), (3,4)
 * (1,3), (2,4)
 * (1,4), (2,3)
 * (1,2,3), (4)
 * (1,2,4), (3)
 * (1,3,4), (2)
 * 示例 3：
 *
 * 输入：n = 20, k = 5
 * 输出：206085257
 * 解释：把 20 颗糖果分配到 5 个手袋种，共有 1881780996 种方式。1881780996 取 109 + 7的模，等于 206085257。
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode.cn/problems/count-ways-to-distribute-candies
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 *
 */
public class Solution {

    // 1692
    public int waysToDistribute(int n, int k) {
        int mod = 1_000_000_000 + 7;
        // n个糖果 放到 k个盒子中 有多少中方式 mod
        long[][] dp = new long[n+1][k+1];
        //  init
        for (int i = 1; i < n+1; i++) {
            dp[i][1] = 1;
        }
        // dp ij 将 前i个糖果 放在 j个盒子里 一共有多少种方式
        // 遍历盒子数
        for (int i = 2; i < k + 1; i++) {
            for (int j = i; j <= n; j++) {
                // 任选j个盒子往里边 使用之前的盒子 或者 开一个新盒子
                dp[j][i] = (dp[j-1][i] * i) % mod + dp[j-1][i-1] % mod;
                dp[j][i] %= mod;
            }
        }
        return (int) dp[n][k];
    }

}
